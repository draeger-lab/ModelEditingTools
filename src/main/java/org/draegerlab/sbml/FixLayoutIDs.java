/**
 *
 */
package org.draegerlab.sbml;

import org.sbml.jsbml.*;
import org.sbml.jsbml.SBMLError.SEVERITY;
import org.sbml.jsbml.ext.layout.*;

import javax.xml.stream.XMLStreamException;
import java.io.File;
import java.io.IOException;
import java.util.logging.Logger;

import static java.text.MessageFormat.format;

/**
 * Reads a model with a layout generated by EscherConverter and tries to connect
 * the layout to a main model with id prefixes, such as "M_" etc.
 *
 * @author draeger
 *
 */
public class FixLayoutIDs {

  private static final Logger logger = Logger.getLogger(FixLayoutIDs.class.getName());

  /**
   * This little script takes care of differences in the ID naming conventions
   * between Escher and BiGG by adding prefixes ({@code M_},{@code R_}, or
   * {@code G_}) where needed and also correcting other cross references.
   *
   * @param args
   *        This method requires as input the paths to three files:
   *        1) The result from a conversion Escher JSON to SBML
   *        2) The model in which the layout is to be inserted.
   *        3) The output file
   * @throws IOException
   * @throws XMLStreamException
   */
  public static void main(String[] args) throws XMLStreamException, IOException {
    SBMLDocument layoutDoc = SBMLReader.read(new File(args[0]));
    SBMLDocument doc = SBMLReader.read(new File(args[1]));
    Model m = doc.getModel();
    LayoutModelPlugin layout = (LayoutModelPlugin) layoutDoc.getModel().getPlugin(LayoutConstants.shortLabel);
    m.addPlugin(LayoutConstants.shortLabel, layout.clone());
    Layout l = ((LayoutModelPlugin) m.getPlugin(LayoutConstants.shortLabel)).getListOfLayouts().get(0);
    int count = 0;
    for (SpeciesGlyph sg : l.getListOfSpeciesGlyphs()) {
      if (sg.isSetSpecies()) {
        String ref = sg.getSpecies();
        String pref = "M";
        if (!ref.startsWith(pref + "_")) {
          sg.setSpecies(createNewReference(ref, pref));
          logger.info(format("{0,number,integer}.\t {1} -> {2}", (++count), ref, sg.getSpecies()));
        }
      }
    }
    count = 0;
    for (TextGlyph tg : l.getListOfTextGlyphs()) {
      if (tg.isSetOriginOfText()) {
        if (tg.getOriginOfTextInstance() == null) {
          String ref = tg.getOriginOfText();
          String prefixes[] = {"M", "R", "G", "SG", "RG", "TG"};
          boolean unavailable = true;
          for (String pref : prefixes) {
            NamedSBase sbase = m.findNamedSBase(createNewReference(ref, pref));
            if (sbase != null) {
              tg.setOriginOfText(sbase.getId());
              logger.warning(format("{0,number,integer}.\t{1} -> {2}", (++count), ref, sbase.getId()));
              unavailable = false;
              break;
            }
          }
          if (unavailable) {
            logger.warning(format("Could not find the model component {0} corresponding to the text glyph {1}", ref, tg.getId()));
          }
        }
      }
    }
    count = 0;
    for (ReactionGlyph rg : l.getListOfReactionGlyphs()) {
      if (rg.isSetReaction() && (rg.getReactionInstance() == null)) {
        String ref = rg.getReaction();
        NamedSBase sbase = m.findNamedSBase(createNewReference(ref, "R"));
        if (sbase != null) {
          rg.setReaction(sbase.getId());
          logger.info(format("{0,number,integer}.\t {1} -> {2}", (++count), ref, sbase.getId()));
        } else {
          logger.warning(format("No corresponding reaction with id ''{0}'' could be found for reaction glyph ''{1}''", rg.getReaction(), rg.getId()));
          continue;
        }
      }
      if (rg.isSetListOfSpeciesReferenceGlyphs()) {
        for (SpeciesReferenceGlyph srg : rg.getListOfSpeciesReferenceGlyphs()) {
          if (srg.isSetSpeciesReference()) {
            String ref = srg.getSpeciesReference();
            NamedSBase sbase = m.findNamedSBase(ref);
            if (sbase == null) {
              Reaction r = (Reaction) rg.getReactionInstance();
              NamedSBase other = layoutDoc.getModel().findNamedSBase(ref);
              if ((other != null) && (other instanceof SpeciesReference)) {
                SpeciesReference sr = (SpeciesReference) other;
                if (sr.isSetSpecies()) {
                  //System.out.println("Found " + sr.getSpecies() + " for " + ref);
                  if (ref.contains("_reactant_")) {
                    setId(r.getListOfReactants(), sr.getSpecies(), ref);
                  } else if (ref.contains("_product_")) {
                    setId(r.getListOfProducts(), sr.getSpecies(), ref);
                  }
                }
              }
            }
          }
        }
      }
    }
    logger.info(args[1]);
    TidySBMLWriter.write(doc, new File(args[2]), ' ', (short) 2);
    doc.checkConsistencyOffline();
    /*for (SBMLError e : doc.getListOfErrors().getErrorsBySeverity(SEVERITY.ERROR)) {
      logger.warning(e.getMessage());
    }*/
  }

  /**
   *
   * @param listOfParticipants
   * @param species
   * @param id
   */
  private static void setId(ListOf<SpeciesReference> listOfParticipants,
    String species, String id) {
    species = createNewReference(species, "M");
    for (SpeciesReference sr : listOfParticipants) {
      if (sr.getSpecies().equals(species)) {
        sr.setId(id);
        logger.info(format("Setting id to {0} for speciesReference to {1}", id, species));
        break;
      }
    }
  }

  /**
   *
   * @param ref
   * @param pref
   * @return
   */
  private static String createNewReference(String ref, String pref) {
    String newRef;
    if (ref.charAt(0) == '_') {
      newRef = pref + ref;
    } else {
      newRef = pref + "_" + ref;
    }
    return newRef;
  }
}
